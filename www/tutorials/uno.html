<html><pre><h4>
You know UNO ?                                                            <a href="help.html">Help!</a>

-------------------------------------------------------------------------------

We continue right where we left where we use our new library from the svx/
charmap dialog. So we have introuced a new project, but now to make it
interesting further by working it up the way most of the OOo code is organized 
- as a UNO component!

UNO components are typically called 'services', and Services implement
'interface's. So we pick the tiniest of Interfaces that we can work with -
XExecutableDialog, with all of two methods specified: execute() and
setTitle() and decide that this is the interface that we will implement as our
helloworld Service. The first thing is to modify the header file:

--- helloworld/inc/helloworld.hxx	2005-07-20 13:17:57.504281011 +0530
+++ helloworld/inc/helloworld.hxx	2005-07-20 13:26:05.653411957 +0530
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XEXECUTABLEDIALOG_HPP_
+#include <com/sun/star/ui/dialogs/XExecutableDialog.hpp>
+#endif

 namespace hello {
 
 	namespace world {
 
-	class HelloWorld {
+	class HelloWorld : public WeakImplHelper1< XExecutableDialog > {
+
+		Reference< XMultiServiceFactory > _xServiceManager;
 
 	public:
 
+		virtual void SAL_CALL setTitle( const OUString& aTitle ) 
+			throw( RuntimeException );
+
+		virtual sal_Int16 SAL_CALL execute( ) 
+			throw( RuntimeException );
+
+		HelloWorld( const Reference< XMultiServiceFactory > & xServiceManager );
+
 		void adios();
 
 		};

Every interface has a header file that we include first, and then the first
derivation  from the WeakImplHelper1 helps our service to be managed better by
the ServiceManager which does reference counting and similar service
management operations. Then we specify the methods in the interface that we
implement - every method in the interface needs to be implemented since they
are all virtual. The ServiceManager reference is passed in to all components,
which we also retain.

Then we flesh out the body of the methods in the component:

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+// XExecutableDialog Methods
+void SAL_CALL HelloWorld::setTitle( const OUString& rTitle ) throw( RuntimeException )
+{
+	fprintf( stderr, "HelloWorld::setTitle: %s\n", OU2A( rTitle ) );
+}
+
+sal_Int16 SAL_CALL HelloWorld::execute() throw( RuntimeException )
+{
+	fprintf( stderr, "HelloWorld::execute\n" );
+}

The real idea of the interface is really to launch a dialog and operate it
till it is shutdown. We'll just output a simple string just to keep the patch
short :-)

[ While we're here, since we hit an OUString that is used throughout OOo,
let's just drop in the OU2A macro that comes in handy a lot of the time:

+#define OU2A(rtlOUString)  (::rtl::OUStringToOString((rtlOUString), RTL_TEXTENCODING_ASCII_US).getStr()) ]

Then we need to implement a function that takes in the ServiceManager as a
parameter and instantiates our object that implements the service:

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+// UNO component instantiator class
+Reference< XInterface > createHelloWorld(
+	const Reference< XMultiServiceFactory > & xMgr )
+{
+	return Reference< XInterface >( static_cast< XExecutableDialog* >( new HelloWorld( xMgr ) ) );
+}

And in order to keep track of the ServiceManager, we include a corresponding
constructor for our class:

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+HelloWorld::HelloWorld( const Reference< XMultiServiceFactory > & xServiceManager )
+	: _xServiceManager( xServiceManager )
+{
+}

That takes care of the operation of the component entirely. Now to fill in the
pieces the UNO environment needs for operation:

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+void SAL_CALL component_getImplementationEnvironment(
+	const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}

This function specifies the environment of the component, which in this case
specifies the C++ component environment.

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+sal_Bool SAL_CALL component_writeInfo( void* pServiceManager, void* pRegistryKey )
+{
+	if ( pRegistryKey )
+	{
+		Reference< XRegistryKey > xNewKey( reinterpret_cast< XRegistryKey * >( pRegistryKey )->createKey(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("/org.openoffice.world.hello/UNO/SERVICES") ) ) );
+		xNewKey->createKey( OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.helloWorld") ) );
+		return sal_True;
+	}
+	return sal_False;
+}

This portion is used to register the component - to write the information
about the component into a registry. It says that the name of the service is
"org.openoffice.helloWorld" and the service implementation has the name
"/org.openoffice.world.hello". Because of this what happens is that when
someone queries for the service name, first the name of the implementation is
given to them for further action.

--- helloworld/source/helloworld.cxx	2005-07-20 13:18:55.965713320 +0530
+++ helloworld/source/helloworld.cxx	2005-07-20 13:33:52.756043677 +0530
+void * SAL_CALL component_getFactory(
+	const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey )
+{
+	void * pRet = 0;
+	if (pServiceManager && !rtl_str_compare( pImplName, "org.openoffice.world.hello" ))
+	{
+		OUString aServiceName( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.helloWorld") );
+		Reference< XSingleServiceFactory > xFactory(
+			createSingleFactory(
+				reinterpret_cast< XMultiServiceFactory * >( pServiceManager ),
+				OUString::createFromAscii( pImplName ),
+				createHelloWorld,
+				Sequence< OUString >( &aServiceName, 1 ) ) );
+		if (xFactory.is())
+		{
+			xFactory->acquire();
+			pRet = xFactory.get();
+		}
+	}
+	return pRet;
+}

This function is what is executed when someone queries for a factory that can
create an instance of the component that contains the implementation that the
registry specifies. What it says is that if someone queries for the
implementation our component provides - "org.openoffice.world.hello", then
return a factory to them with the name of the instantiating function which
here is 'createHelloWorld'.

These 3 functions are enclosed in an extern "C" so that the binary interface
is exported without C++ mangling of the function names, and our component is
ready to be built with one more change:

--- helloworld/source/makefile.mk	2005-07-20 13:15:10.908549636 +0530
+++ helloworld/source/makefile.mk	2005-07-09 17:20:38.000000000 +0530
@@ -15,6 +15,8 @@ SLOFILES=\
 
 SHL1TARGET= 	hworld$(UPD)$(DLLPOSTFIX)
 SHL1LIBS=       $(SLB)$/helloworld.lib
+SHL1STDLIBS=\
+	$(CPPUHELPERLIB) 
 
 # --- Targets ----------------------------------
 

Voila! That builds our shining new UNO helloworld component for us, all ready
and waiting for action, so we shift gears in the charmap dialog and invoke our
method UNO style:

--- svx/source/dialog/charmap.cxx	2004-07-13 15:15:11.000000000 +0530
+++ svx/source/dialog/charmap.cxx	2005-07-20 13:57:39.557992653 +0530
@@ -117,6 +119,9 @@
 #ifndef _COMPHELPER_TYPES_HXX_
 #include <comphelper/types.hxx>
 #endif
+#ifndef _UNOTOOLS_PROCESSFACTORY_HXX
+#include <comphelper/processfactory.hxx>
+#endif
 
 #include "rtl/ustrbuf.hxx"
 
@@ -1097,6 +1102,17 @@ void SvxCharMapData::SetCharFont( const 
 
 IMPL_LINK( SvxCharMapData, OKHdl, OKButton *, EMPTYARG )
 {
+    Reference< XExecutableDialog > xHelloWorld( ::comphelper::getProcessServiceFactory()->
+        createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.helloWorld") ) ), UNO_QUERY );
+
+    if( xHelloWorld.is() )
+    {
+        xHelloWorld->execute();
+    }
+    else
+        fprintf( stderr, "Unable to instantiate xHelloWorld.\n" );
+
+
     String aStr = aShowText.GetText();
 
     if ( !aStr.Len() )

By invoking the global service factory to create an instance of our new
component for us, we pass it the name of the service that we want to use and
ask it to create one instance of it for us.

Which of course fails :-) so what does happen is the printing of the error
message that it is unable to instantiate xHelloWorld.

While the component is built and ready, what happens is that all components
are registered into the central registry which specifies the complete list of
components available and where their implementations lie, which is in
$OOoInstall/program/services.rdb. Which in turn is definitely not aware of our
component and therefore the query for our service fails.

Enter regview and regcomp :-) regview is the registry viewer that is built in
registry/ and copied over to the solver, so the path to regview goes:
solver/680/unxlngi4.pro/bin/regview. This is of course unnecessary if
LinuxIntelEnvSet.sh is sourced, since that places the solver's bin/ directory
in the $PATH.

So if we shift over to the $OOoInstall/program directory and issue:

regview services.rdb | less

we would see the entire list of services and their implementations and
checking for 'helloWorld' would confirm that our library is not registered
within.

What we therefore need to do is register our component implemented by our so
into this registry, so we go:

regcomp -register -r services.rdb -c libhworld680li.so

and do a regview to check for the 'helloWorld' entry and success! :-)

This time we run the code in charmap, the registry returns the right service
implementation instance and execute()s it! w00t! :-)

Similarly, regcomp -revoke -r services.rdb -c libhworld680li.so would remove
the registry entry and we'd get back our error message :-) Do note that
services.rdb is usually installed as read-only and it would probably be
necessary to change its permissions in order to write/register/revoke to the
registry. 

-------------------------------------------------------------------------------

<a href="helloworld-uno-style.diff.txt">helloworld-uno-style.diff</a>                                             Next: <a href="idl.html">idl</a>
</h4></pre></html>